## HashMap 的长度为什么是2的幂次方
为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) & hash”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。

这个算法应该如何设计呢？

我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。

为什么hash%length==hash&(length-1)?

当length为2的n次方的时候，即2^n时，其二进制表示形式为：

|2^n|2^n - 1|
|---|---|
|1 0...(n个0)|0 1...(n个1)|

那么此时hash与2^n - 1求与的结果就是，hash的二进制数第n位(从1开始)之前(不含第n位)的数都是在和0求与，从第n位(包含)开始，都是在和1求与，最终求与的结果等价于：保留hash的低n位二进制数，且求与后的数值范围是在[0, length-1]，和hash%length的数学意义相同

计算示例
-------
| |十进制|二进制|
|---|---|---|
|hash|17|10001|
|length|2^4=16|10000|
|hash = x * length + 余数|17= 16 + 1|/|
|hash&(length-1)|1|10001 ^ 01111 = 00001|

## 扰动函数
扰动函数就是HashMap的hash方法。使用扰动函数是为了防止一些实现比较差的hashCode()方法， 也就是为了减少碰撞。
## 解决碰撞的方法
- JDK 1.7 拉链法
将链表和数组结合，也就是创建一个链表数组，每个数组元素就是一个链表，若遇到哈希冲突，则将冲突的值加入到链表中。

- JDK 1.8 链表/红黑树
当链表长度大于阈值（默认8）时，将链表转换为红黑树，以减少搜索时间。