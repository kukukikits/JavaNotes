## 1. 栈
栈的方法如下
```java
interface Stack<T> {
    void clearStack();
    boolean isEmpty();
    boolean isFull();
    T getTop();
    void push(T ele);
    T pop();
    int size();
}
```
### 1.1  顺序栈
顺序栈使用一维数组保存元素，比较消耗空间。如果栈内有n个元素，一般使用n-1作为顶部元素，入栈和出栈都发生在n-1的位置。
```java
class 顺序栈<T> implements Stack<T> {
    private Object[] array;
    private int top;

    public 顺序栈(int capacity) {
        this.top = 0;
        this.array = new Object[capacity];
    }

    public void clearStack() {
        array = new Object[array.length];
        top = 0;
    }

    public boolean isEmpty() {
        return top == 0;
    }

    public boolean isFull() {
        return top == array.length;
    }

    public T getTop() {
        if (!isEmpty()) {
            return (T)array[top - 1];
        }
        throw new NoSuchElementException();
    }

    public void push(T ele) {
        if (isFull()) {
            throw new StackOverflowError();
        }
        array[top++] = ele;
    }

    public T pop() {
        if (!isEmpty()) {
            return (T)array[--top];
        }
        throw new NoSuchElementException();
    }

    public int size() {
        return top;
    }
}

```

### 1.2 链式栈
链式栈使用链表存储元素，需要付出额外的结构空间
```java
class LinkedStack<T> implements Stack<T> {

    private static class Node<T> {
        T value;
        Node<T> next;
        public Node(T value, Node<T> next) {
            this.value = value;
            this.next = next;
        }
    }

    private Node<T> top;
    private int size;
    private final int capacity;
    public LinkedStack(int capacity) {
        this.capacity = capacity;
    }
    public LinkedStack() {
        this.capacity = Integer.MAX_VALUE;
    }

    @Override
    public void clearStack() {
        this.top = null;
        size = 0;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }

    @Override
    public T getTop() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        return top.value;
    }

    @Override
    public void push(T ele) {
        if (isFull()) {
            throw new StackOverflowError();
        }
        size++;
        top = new Node<>(ele, top);
    }

    @Override
    public T pop() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        size--;
        Node<T> t = top;
        top = t.next;
        t.next = null;
        return t.value;
    }

    @Override
    public int size() {
        return size;
    }
}
```


### 1.3 栈的应用举例
#### 1.3.1 数制的转换
十进制数N和d进制数的转换的基本原理：
[原理详解见链接：https://www.cnblogs.com/generator/p/10700965.html](https://www.cnblogs.com/generator/p/10700965.html)

1. N mode d 得余数，余数作为转化后的值push进栈
2. 用N div d 得商，商再作为N的新值，重复步骤1，直到商数为0。
3. 最后所有得到的余数反向输出，即栈pop，就是我们需要的d进制数

实现：
```java
    /**
     * @param n 十进制数
     * @param radix 目标进制
     * @return 转换后的值
     */
    public static String convert(int n, int radix) {
        Stack<Integer> stack = new Stack<>();
        while (n!= 0) {
            int yu = n % radix; // n = n/radix + yu，其中n/radix是radix的整数倍，这一部分数据产生进位。yu是余数，余数永远小于radix
            stack.push(yu);
            n = n/radix;  // 相当于抹除radix进制的最右边的一位数，如n=123，n/10=12，其中各位上的3被抹除了
        }
        StringBuilder builder = new StringBuilder();
        while (!stack.isEmpty()) {
            Integer pop = stack.pop();
            if (pop > 9) {
                builder.append((char)(pop + 55));
            } else {
                builder.append(pop);
            }
        }
        return builder.toString();
    }
```

