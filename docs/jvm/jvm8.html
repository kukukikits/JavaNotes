<!DOCTYPE html><html><head>
      <title>jvm8</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:///c:\Users\geshengbin\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.5.1\node_modules\@shd101wyy\mume\dependencies\katex\katex.min.css">
      
      

      
      
      
      
      
      
      

      <style>
      /**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
code[class*="language-"],
pre[class*="language-"] {
  color: #333;
  background: none;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.4;

  -moz-tab-size: 8;
  -o-tab-size: 8;
  tab-size: 8;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  padding: .8em;
  overflow: auto;
  /* border: 1px solid #ddd; */
  border-radius: 3px;
  /* background: #fff; */
  background: #f5f5f5;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
  background: #f5f5f5;
}

.token.comment,
.token.blockquote {
  color: #969896;
}

.token.cdata {
  color: #183691;
}

.token.doctype,
.token.punctuation,
.token.variable,
.token.macro.property {
  color: #333;
}

.token.operator,
.token.important,
.token.keyword,
.token.rule,
.token.builtin {
  color: #a71d5d;
}

.token.string,
.token.url,
.token.regex,
.token.attr-value {
  color: #183691;
}

.token.property,
.token.number,
.token.boolean,
.token.entity,
.token.atrule,
.token.constant,
.token.symbol,
.token.command,
.token.code {
  color: #0086b3;
}

.token.tag,
.token.selector,
.token.prolog {
  color: #63a35c;
}

.token.function,
.token.namespace,
.token.pseudo-element,
.token.class,
.token.class-name,
.token.pseudo-class,
.token.id,
.token.url-reference .token.variable,
.token.attr-name {
  color: #795da3;
}

.token.entity {
  cursor: help;
}

.token.title,
.token.title .token.punctuation {
  font-weight: bold;
  color: #1d3e81;
}

.token.list {
  color: #ed6a43;
}

.token.inserted {
  background-color: #eaffea;
  color: #55a532;
}

.token.deleted {
  background-color: #ffecec;
  color: #bd2c00;
}

.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}


/* JSON */
.language-json .token.property {
  color: #183691;
}

.language-markup .token.tag .token.punctuation {
  color: #333;
}

/* CSS */
code.language-css,
.language-css .token.function {
  color: #0086b3;
}

/* YAML */
.language-yaml .token.atrule {
  color: #63a35c;
}

code.language-yaml {
  color: #183691;
}

/* Ruby */
.language-ruby .token.function {
  color: #333;
}

/* Markdown */
.language-markdown .token.url {
  color: #795da3;
}

/* Makefile */
.language-makefile .token.symbol {
  color: #795da3;
}

.language-makefile .token.variable {
  color: #183691;
}

.language-makefile .token.builtin {
  color: #0086b3;
}

/* Bash */
.language-bash .token.keyword {
  color: #0086b3;
}

/* highlight */
pre[data-line] {
  position: relative;
  padding: 1em 0 1em 3em;
}
pre[data-line] .line-highlight-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  background-color: transparent;
  display: block;
  width: 100%;
}

pre[data-line] .line-highlight {
  position: absolute;
  left: 0;
  right: 0;
  padding: inherit 0;
  margin-top: 1em;
  background: hsla(24, 20%, 50%,.08);
  background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));
  pointer-events: none;
  line-height: inherit;
  white-space: pre;
}

pre[data-line] .line-highlight:before, 
pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-start);
  position: absolute;
  top: .4em;
  left: .6em;
  min-width: 1em;
  padding: 0 .5em;
  background-color: hsla(24, 20%, 50%,.4);
  color: hsl(24, 20%, 95%);
  font: bold 65%/1.5 sans-serif;
  text-align: center;
  vertical-align: .3em;
  border-radius: 999px;
  text-shadow: none;
  box-shadow: 0 1px white;
}

pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-end);
  top: auto;
  bottom: .4em;
}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
    </head>
    <body for="html-export">
      <div class="mume markdown-preview  ">
      <h1 class="mume-header" id="chapter-2-the-structure-of-the-java-virtual-machine">Chapter 2 The Structure of the Java Virtual Machine</h1>

<h2 class="mume-header" id="21-the-class-file-format">2.1 The <em>class</em> File Format</h2>

<p>Compiled code to be executed by the Java Virtual Machine is represented using a hardware- and operating system-independent binary format, typically (but bot necessarily) stored in a file, known as the <em>class</em> file format. The <em>class</em> file format precisely defines the representation of a class or interface, including details such as byte ordering that might be taken for granted in a platform-specific object file format.</p>
<h2 class="mume-header" id="22-data-types">2.2 Data Types</h2>

<p>&#x1F31F; <strong>Like the Java programming language, the Java Virtual Machine operate on two kinds of types: primitive types and reference types.</strong> There are, correspondingly, two kinds of values that can be stored in variables, passed as arguments, returned by methods, and operated upon: primitive values and reference values.</p>
<p>The Java Virtual Machine expects that nearly all type checking is done prior to run time, typically by a compiler, and does not have to be done by the Java Virtual Machine itself. Values of primitive types need not be tagged or otherwise be inspectable to determine their types at run time, or to be distinguished from values of reference types. Instead, the instruction set of the Java Virtual Machine distinguishes its operand types using instructions intended to operate on values of specific types. For instance, <em>iadd</em>, <em>ladd</em>, <em>fadd</em>, and dadd are all Java Virtual Machine instructions that add two numeric values and produce numeric results, but each is specialized for its operand type: <em>int</em>, <em>long</em>, <em>float</em>, and <em>double</em>.</p>
<p>The Java Virtual Machine contains explicit support for objects. <strong>An object is either a dynamically allocated class instance or an array.</strong> A reference to an object is considered to have Java Virtual Machine type <em>reference</em>. Values of type <em>reference</em> can be thought of as pointers to objects. More than one reference to an object may exist. Objects are always operated on, passed, and tested via values of type <em>reference</em>.</p>
<h2 class="mume-header" id="23-primitive-types-and-values">2.3 Primitive Types and Values</h2>

<p>&#x1F31F; The primitive data types supported by the Java Virtual Machine are the <strong>numeric</strong> types, the <strong>boolean</strong> type, and the <strong>returnAddress</strong> type.</p>
<p>&#x2721;&#xFE0F; The numeric types consist of the <strong>integral types</strong> and the <strong>floating-point types</strong>.</p>
<p>The integral types:</p>
<ul>
<li>byte, 8-bit, default 0</li>
<li>short, 16-bit, default 0</li>
<li>int, 32-bit, default 0</li>
<li>long, 64-bit, default 0</li>
<li>char, 16-bit, default value is the null code point(\u0000)</li>
</ul>
<p>The floating-pint types are:</p>
<ul>
<li>float, default value is positive 0</li>
<li>double, default value is positive 0</li>
</ul>
<p>boolean type:</p>
<ul>
<li>true and false, default is false</li>
</ul>
<p>The values of the <strong>returnAddress</strong> type are pointers to the <strong>opcodes</strong> of Java Virtual Machine instructions. Of the primitive types, only the <strong>returnAddress</strong> type is not directly associated with a Java programming language type.</p>
<h3 class="mume-header" id="231-integral-types-and-values">2.3.1 Integral Types and Values</h3>

<h3 class="mume-header" id="232-floating-point-types-value-sets-and-values">2.3.2 Floating-Point Types, Value Sets, and Values</h3>

<h3 class="mume-header" id="233-the-returnaddress-type-and-values">2.3.3 The returnAddress Type and Values</h3>

<p>The values of the returnAddress type are pointers to the opcodes of Java Virtual Machine instructions. Unlike the numeric primitive types, the returnAddress type does not correspond to any Java programming language type and cannot be modified by the running program</p>
<h3 class="mume-header" id="234-the-boolean-type">2.3.4 The boolean Type</h3>

<p>Although the Java Virtual Machine defines a boolean type, it only provides very limited support for it. There are no Java Virtual Machine instructions solely dedicated to operations on boolean values. Instead, expressions in the Java programming language that operate on boolean values are compiled to use values of the Java Virtual Machine <em>int</em> data type.</p>
<p>The Java Virtual Machine does directly support <em>boolean</em> arrays. Its <em>newarray</em> instruction enables creation of <em>boolean</em> arrays. Arrays of type boolean are accessed and modified using the <em>byte</em> array instructions <em>baload</em> and <em>bastore</em>.</p>
<blockquote>
<p>In Oracle&apos;s Java Virtual Machine implementation, <em>boolean</em> arrays in the Java programming language are encoded as Java Virtual Machine <em>byte</em> arrays, using 8 bits per boolean element.</p>
</blockquote>
<p>The Java Virtual Machine encodes boolean array components using 1 to represent true and 0 to represent false. Where Java programming language <em>boolean</em> values are mapped by compilers to values of Java Virtual Machine type <em>int</em>, the compilers must use the same encoding.</p>
<h2 class="mume-header" id="24-reference-types-and-values">2.4 Reference Types and Values</h2>

<p>Three kinds of reference types:</p>
<ul>
<li>class types</li>
<li>array types</li>
<li>interface types<br>
Their values are references to dynamically created class instances, arrays, or class instances or arrays that implement interfaces, respectively.</li>
</ul>
<p>An array type consists of a component type with a single dimension (whose length is not given by the type).(&#x6570;&#x7EC4;&#x7C7B;&#x578B;&#x7531;&#x4E00;&#x4E2A;&#x4E00;&#x7EF4;&#x7684;&#x7EC4;&#x4EF6;&#x7C7B;&#x578B;&#x6784;&#x6210;) The component type of an array type may itself be an array type. If, starting from any array type, one considers its component type, and then (if that is also an array type) the component type of that type, and so on, eventually one must reach a component type that is not an array type; this is called the &#x1F38F; <strong>element type</strong>. The element type of an array type if necessarily either a primitive type, or a class type, or an interface type.</p>
<p>A <em>reference</em> value may also be the special null reference, a reference to no object, which will be denoted here by <em>null</em>. The <em>null</em> reference initially has no run-time type, but may be cast to any type. The default value of a <em>reference</em> type is <em>null</em>.</p>
<p>This specification does not mandate a concrete value encoding null.</p>
<h2 class="mume-header" id="25-run-time-data-areas">2.5 Run-Time Data Areas</h2>

<p>The Java Virtual Machine defines various run-time data areas the are used during execution of a program. Some of these data areas are created on Java Virtual Machine start-up and are destroyed only when the Java Virtual Machine exits. Other data areas are per thread. Per-thread data areas are created when a thread created and destroyed when the thread exists.</p>
<h3 class="mume-header" id="252-the-_pc_-register-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8">2.5.2 The <em>pc</em> Register &#x7A0B;&#x5E8F;&#x8BA1;&#x6570;&#x5668;</h3>

<p>The Java Virtual Machine can support many threads of execution at once. &#x1F4D7; <strong>Each Java Virtual Machine thread has its own pc (program counter) register.</strong></p>
<p>At any point, each Java Virtual Machine thread is executing the code of a single method, namely the current method($2.6) for that thread.</p>
<ul>
<li>If that method is not <em>native</em>, the <strong>pc</strong> register contains the address of the Java Virtual Machine instruction currently being executed.</li>
<li>If the method currently being executed by the thread is <em>native</em>, the value of the Java Virtual Machine&apos;s <strong>pc</strong> register is undefined.</li>
</ul>
<p>The Java Virtual Machine&apos;s <strong>pc</strong> register is wide enough to hold a returnAddress or a native pointer on the specific platform.</p>
<h3 class="mume-header" id="252-java-virtual-machine-stacks-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">2.5.2 Java Virtual Machine Stacks (Java&#x865A;&#x62DF;&#x673A;&#x6808;)</h3>

<p>&#x1F370; <strong>Each Java Virtual Machine thread has a private <em>Java Virtual Machine stack</em>, created at the same time as the thread.</strong> A Java Virtual Machine stack stores frames ($2.6). A Java Virtual Machine stack is analogous to the stack of a conventional language such as C: it holds local variables and partial results, and plays a part in method invocation and return. Because the Java Virtual Machine stack is never manipulated directly except to push and pop frames, frames may be heap allocated. The memory for a Java Virtual Machine stack does not need to be contiguous.</p>
<p>This specification permits Java Virtual Machine stacks either to be of a fixed size or to dynamically expand and contract as required by the computation. If the Java Virtual Machine stacks are of a fixed size, the size of each Java Virtual Machine stack may be chosen independently when that stack is created.</p>
<blockquote>
<p>A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of Java Virtual Machine stacks, as well as, in the case of dynamically expanding or contracting Java Virtual Machine stacks, control over the maximum and minimum sizes.</p>
</blockquote>
<blockquote>
<p>&#x1F424; &#x4E0A;&#x9762;&#x7684;&#x610F;&#x601D;&#x5C31;&#x662F;&#x8BF4;&#xFF0C;Java&#x865A;&#x62DF;&#x673A;&#x6808;&#x7684;&#x5927;&#x5C0F;&#x6CA1;&#x6709;&#x505A;&#x5F3A;&#x5236;&#x8981;&#x6C42;&#xFF0C;&#x7531;&#x865A;&#x62DF;&#x673A;&#x5177;&#x4F53;&#x5B9E;&#x73B0;&#x6765;&#x786E;&#x5B9A;&#x3002;</p>
</blockquote>
<p>&#x1F4BC; &#x5173;&#x4E8E;Java&#x865A;&#x62DF;&#x673A;&#x6808;&#x7684;&#x4E24;&#x79CD;Exception:<br>
The following exceptional conditions are associated with Java Virtual Machine stacks:</p>
<ul>
<li>If the computation is a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a <em>StackOverflowError</em>.</li>
<li>If Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws an <em>OutOfMemoryError</em>.</li>
</ul>
<h3 class="mume-header" id="253-heap-%E5%A0%86">2.5.3 Heap (&#x5806;)</h3>

<p>The Java Virtual Machine has a <em>heap</em> that is shared among all Java Virtual Machine threads. The heap is the run-time data area from which memory for all class instances and arrays is allocated.</p>
<p>The heap is created on virtual machine start-up. Heap storage for objects is reclaimed by an automatic storage management system (known as a garbage collector); objects are never explicitly deallocated.</p>
<p>The following exceptional condition is associated with the heap:</p>
<ul>
<li>If a computation requires more heap than can be made available by the automatic storage management system, the Java Virtual Machine throws an <em>OutOfMemoryError</em>.</li>
</ul>
<h3 class="mume-header" id="254-method-area">2.5.4 Method Area</h3>

<p>The Java Virtual Machine has a <em>method area</em> that is shared among all Java Virtual Machine threads. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods ($2.9) used in class and instance initialization and interface initialization.</p>
<p>The method area is created on virtual machine start-up. Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact.</p>
<p>The following exceptional condition is associated with the method area:</p>
<ul>
<li>If memory in the method area cannot be made available to satisfy an allocation request, the Java Virtual Machine throws an <em>OutOfMemoryError</em>.</li>
</ul>
<h3 class="mume-header" id="255-run-time-constant-pool">2.5.5 Run-Time Constant Pool</h3>

<p><strong>A <em>run-time constant pool</em> is a per-class or per-interface run-time representation of the <em>constant_pool</em> table in a <em>class</em> file</strong> ($4.4). It contains several kinds of constants, ranging from numeric literals known at compile-time to method and field references that must be resolved at run-time.</p>
<p>Each run-time constant pool is allocated from the Java Virtual Machine&apos;s method area ($2.5.4). The run-time constant pool for a class or interface is constructed when the class or interface is created ($5.3) by the Java Virtual Machine.</p>
<p>The following exceptional condition is associated with the construction of the run-time constant pool:</p>
<ul>
<li>When creating a class or interface, if the construction of the run-time constant pool requires more memory than can be made available in the method area of the Java Virtual Machine, the Java Virtual Machine throws an <em>OutOfMemoryError</em>.</li>
</ul>
<blockquote>
<p>See $5 (Loading, Linking, and Initializing) for information about the construction of the run-time constant pool.</p>
</blockquote>
<h3 class="mume-header" id="256-native-method-stacks">2.5.6 Native Method Stacks</h3>

<p>An implementation of the Java Virtual Machine may use conventional stacks, colloquially called &quot;C stacks&quot;, to support <em>native</em> methods (methods written in a language other than the Java programming language). Native method stacks may also be used by the implementation of an interpreter for the Java Virtual Machine&apos;s instruction set in a language such as C. Java Virtual Machine implementations that cannot load <em>native</em> methods and that do not themselves rely on conventional stacks need to supply native method stacks. <strong>If supplied, native method stacks are typically allocated per thread when each thread is created.</strong></p>
<p>The following exceptional conditions are associated with native method stacks:</p>
<ul>
<li>If the computation in a thread requires a larger native method stack than is permitted, the Java Virtual Machine throws a <em>StackOverflowError</em>.</li>
<li>If native method stacks can be dynamically expanded and native method stack expansion is attempted but insufficient memory can be made available, or if insufficient memory can be made available to create the initial native method stack for a new thread, the Java Virtual Machine throws an <em>OutOfMemoryError</em>.</li>
</ul>
<h2 class="mume-header" id="26-frames">2.6 Frames</h2>

<p><strong>A frame is used to store data and partial results, as well as to perform dynamic linking, return values for methods, and dispatch exceptions.</strong></p>
<p>A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes, whether that completion is normal or abrupt (it throws an uncaught exception). Frames are allocated from the Java Virtual Machine stack (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2.5.2</mn><mo stretchy="false">)</mo><mi>o</mi><mi>f</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>c</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>f</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>E</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>f</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>h</mi><mi>a</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>s</mi><mi>o</mi><mi>w</mi><mi>n</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mi>o</mi><mi>f</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>v</mi><mi>a</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">2.5.2) of the thread creating the frame. Each frame has its own array of local variables (</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mord">.</span><span class="mord">2</span><span class="mclose">)</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mopen">(</span></span></span></span>2.6.1), its own operand stack (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2.6.2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>a</mi><mi>n</mi><mi>d</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>f</mi><mi>e</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mi>t</mi><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>u</mi><mi>n</mi><mo>&#x2212;</mo><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>t</mi><mi>p</mi><mi>o</mi><mi>o</mi><mi>l</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">2.6.2), and a reference to the run-time constant pool (</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">6</span><span class="mord">.</span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">&#x2212;</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">(</span></span></span></span>2.5.5) of the class of the current method.</p>
<blockquote>
<p>A frame may be extended with additional implementation-specific information, such as debugging information</p>
</blockquote>
<p>The sizes of the local variables array and the operand stack are determined at compile-time and are supplied along with the code for the method associated with the frame ($4.7.3). Thus the size of the frame data structure depends only on the implementation of the Java Virtual Machine, and the memory for these structures can be allocated simultaneously on method invocation.</p>
<p>Only one frame, the frame for the executing method, is active at any point in a given thread of control. This frame is referred to as the <strong>current frame</strong>, and its method is known as the <strong>current method</strong>. The class in which the current method is defined is the <strong>current class</strong>. Operations on local variables and the operand stack typically with reference to the current frame.</p>
<p>A frame ceases to be current if its method invokes another method or if its method completes. When a method is invoked, a new frame is created and becomes current when control transfers to the new method. On method return, the current frame passes back the result fo its method invocation, if any, to the previous frame. The current frame is then discarded as the previous frame becomes the current one.</p>
<p>Note that a frame created by a thread is local to that thread can cannot be referenced by any other thread.</p>
<h3 class="mume-header" id="261-local-variables">2.6.1 Local Variables</h3>

<p><strong>Each frame ($2.6) contains an array of variables known as its local variables</strong>. The length of the local variable array of a frame is determined at compile-time and supplied in the binary representation of a class or interface along with the code for the method associated with the frame ($4.7.3).</p>
<p>A single local variable can hold a value of type <strong>boolean, byte, char, short, int, float, reference, or returnAddress</strong>. A pair of local variables can hold a value of type long or double.</p>
<p>Local variables are addressed by indexing. The index of the first local variable is 0. An integer is considered to be an index into the local variable array if and only if that integer is between 0 and one less than the size of the local variable array.</p>
<p>A value of type <em>long</em> or type <em>double</em> occupies two consecutive local variables. Such a value may only be addressed using the lesser index. For example, a value of type double store in the local variable array at index <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> actually occupies the local variables with indices <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>; however, the local variable at index <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> cannot be loaded from. It can be stored into. However, doing so invalidates the contents of local variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>. (n+1&#x4E0B;&#x6807;&#x7684;&#x672C;&#x5730;&#x53D8;&#x91CF;&#x4E0D;&#x80FD;&#x52A0;&#x8F7D;&#xFF0C;&#x4F46;&#x662F;&#x53EF;&#x4EE5;&#x5199;&#x5165;&#xFF0C;&#x4F46;&#x662F;&#x5199;&#x5165;&#x7684;&#x540E;&#x679C;&#x5C31;&#x662F;&#x4E0B;&#x6807;&#x4E3A;n&#x7684;&#x6570;&#x636E;&#x5C31;&#x65E0;&#x6548;&#x4E86;)</p>
<p>The Java Virtual Machine does not require <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> to be even. In intuitive terms, values of type <em>long</em> and <em>double</em> need not be 64-bit aligned in the local variables array. Implementors are free to decide the appropriate way to represent such values using the two local variables reserved for the value.</p>
<p>The Java Virtual Machine uses local variables to pass parameters on method invocation. On class method invocation, any parameters are passed in consecutive local variables staring from local variable 0. On instance method invocation, local variable 0 is always used to pass a reference to the object on which the instance method is being invoked (<strong>this</strong> in the Java programming language). Any parameters are subsequently passed in consecutive local variables staring from local variable 1.</p>
<h3 class="mume-header" id="262-operand-stacks">2.6.2 Operand Stacks</h3>

<p><strong>Each frame ($2.6) contains a last-in-first-out (LIFO) stack known as its operand stack.</strong> The maximum depth of the operand stack of a frame is determined at compile-time and is supplied along with code for the method associated with the frame ($4.7.3).</p>
<p>Where it is clear by context, we will sometimes refer to the operand stack of the current frame as simply the operand stack.</p>
<p>The operand stack is empty when the frame that contains it is created. The Java Virtual Machine supplies instructions to load constants or values from local variables or fields onto the operand stack. Other Java Virtual Machine instructions take operands from the operand stack, operate on them, and push the result back onto the operand stack. The operand stack is also used to prepare parameters to be passed to methods and to receive method results.</p>
<p>For example, the <strong>iadd</strong> instruction adds two int values together. It requires that the int values to be added be the top two values of the operand stack, pushed there by previous instructions. Both of the int values are popped from the operand stack. They are added, and their sum is pushed back onto the operand stack. Sub-computations may be nested on the operand stack, resulting in values that can be used by the encompassing computation.</p>
<p>Each entry on the operand stack can hold a value of any Java Virtual Machine type, including a value of type <strong>long</strong> or type <strong>double</strong>.</p>
<p>Values from the operand stack must be operated upon in ways appropriate to their types. It is not possible, for example, to push two <strong>int</strong> values and subsequently treat them as a <strong>long</strong> or to push two <strong>float</strong> values and subsequently add them with an <strong>iadd</strong> instruction. A small number of Java Virtual Machine instructions (the <strong>dup</strong> instructions and <strong>swap</strong>) operate on run-time data areas as raw values without regard to their specific types; these instructions are defined in such a way that they cannot be used to modify or break up individual values. These restrictions on operand stack manipulation are enforced through <strong>class</strong> file verification($4.10).</p>
<p>At any point in time, an operand stack has an associated depth, where a value of type <strong>long</strong> or <strong>double</strong> contributes two units to the depth and a value of any other type contributes one unit.</p>
<h3 class="mume-header" id="263-dynamic-linking">2.6.3 Dynamic Linking</h3>

<p>Each frame ($2.6) contains a reference to the run-time constant pool ($2.5.5) for the type of the current method to support <strong>dynamic linking</strong> of the method code. The <strong>class</strong> file code for a method refers to methods to be invoked and variables to be accessed via symbolic references. Dynamic linking translates these symbolic method references into concrete method references, loading classes as necessary to resolve as-yet-undefined symbols, and translates variable accesses into appropriate offsets in storage structures associated with the run-time location of these variables.</p>
<p>This late binding of the methods and variables makes changes in other classes that a method uses less likely to break this code.<br>
&#x8FD9;&#x79CD;&#x65B9;&#x6CD5;&#x548C;&#x53D8;&#x91CF;&#x7684;&#x540E;&#x671F;&#x7ED1;&#x5B9A;&#xFF0C;&#x5373;&#x4F7F;&#x5728;&#x65B9;&#x6CD5;&#x5185;&#x90E8;&#x8C03;&#x7528;&#x7684;&#x5176;&#x4ED6;&#x7C7B;&#x7684;&#x65B9;&#x6CD5;/&#x53D8;&#x91CF;&#x7B49;&#x53D1;&#x751F;&#x4E86;&#x53D8;&#x5316;&#xFF0C;&#x4E5F;&#x4E0D;&#x4F1A;&#x7834;&#x574F;&#x5F53;&#x524D;&#x65B9;&#x6CD5;&#x7684;&#x52A8;&#x6001;&#x94FE;&#x63A5;&#x3002;&#xFF08;&#x5E94;&#x8BE5;&#x5C31;&#x662F;&#x8FD9;&#x4E2A;&#x610F;&#x601D;&#x5427;&#xFF09;</p>
<h3 class="mume-header" id="264-normal-method-invocation-completion-%E6%96%B9%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%BF%94%E5%9B%9E">2.6.4 Normal Method Invocation Completion &#x65B9;&#x6CD5;&#x6B63;&#x5E38;&#x8FD4;&#x56DE;&#xFF1F;</h3>

<p>A method invocation <strong>completes normally</strong> if that invocation does not cause an exception ($2.10) to be thrown, either directly from the Java Virtual Machine or as a result of executing an explicit <strong>throw</strong> statement. If the invocation of the current method completes normally, then a value may be returned to the invoking method. This occurs when the invoked method executes one of the return instructions ($2.11.8), the choice of which must be appropriate for the type of the value being returned (if any).</p>
<p>The current frame ($2.6) is used in this case to restore the state of the invoker, including its local variables and operand stack, with the program counter of the invoker appropriately incremented to skip past the method invocation instruction.<br>
&#x5728;&#x8FD9;&#x79CD;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x4F7F;&#x7528;&#x5F53;&#x524D;&#x5E27;(&#xA7;2.6)&#x6765;&#x6062;&#x590D;&#x8C03;&#x7528;&#x7A0B;&#x5E8F;&#x7684;&#x72B6;&#x6001;&#xFF0C;&#x5305;&#x62EC;&#x5B83;&#x7684;&#x5C40;&#x90E8;&#x53D8;&#x91CF;&#x548C;&#x64CD;&#x4F5C;&#x6570;&#x6808;&#xFF0C;&#x5E76;&#x9002;&#x5F53;&#x589E;&#x52A0;&#x8C03;&#x7528;&#x7A0B;&#x5E8F;&#x7684;&#x7A0B;&#x5E8F;&#x8BA1;&#x6570;&#x5668;&#x4EE5;&#x8DF3;&#x8FC7;&#x65B9;&#x6CD5;&#x8C03;&#x7528;&#x6307;&#x4EE4;&#x3002;<br>
Execution then continues normally in the invoking method&apos;s frame with the returned value (if any) pushed onto the operand stack of that frame.</p>
<h3 class="mume-header" id="265-abrupt-method-invocation-completion-%E5%BC%82%E5%B8%B8%E8%BF%94%E5%9B%9E">2.6.5 Abrupt Method Invocation Completion &#x5F02;&#x5E38;&#x8FD4;&#x56DE;</h3>

<p>A method invocation <em><strong>completes abruptly</strong></em> if execution of a Java Virtual Machine instruction within the method causes the Java Virtual Machine to throw an exception (&#xA7;2.10), and that exception is not handled within the method. Execution of an <em><strong>athrow</strong></em> instruction (&#xA7;<em><strong>athrow</strong></em>) also causes an exception to be explicitly thrown and, if the exception is not caught by the current method, results in abrupt method invocation completion. A method invocation that completes abruptly never returns a value to its invoker.<br>
&#x4E5F;&#x5C31;&#x662F;&#x8BF4;&#x65B9;&#x6CD5;&#x629B;&#x51FA;&#x4E86;&#x5F02;&#x5E38;&#xFF0C;&#x800C;&#x8C03;&#x7528;&#x8005;&#x6CA1;&#x6709;&#x6355;&#x83B7;&#x5F02;&#x5E38;&#xFF0C;&#x5219;&#x65B9;&#x6CD5;&#x662F;&#x5F02;&#x5E38;&#x8FD4;&#x56DE;&#x7684;&#x3002;</p>
<h2 class="mume-header" id="27-representation-of-objects">2.7 Representation of Objects</h2>

<p>The Java Virtual Machine does not mandate any particular internal structure for objects.</p>
<blockquote>
<p>In some of Oracle&apos;s implementations of the Java Virtual Machine, a reference to a class instance is a pointer to a <em>handle</em> that is itself a pair of pointers: one to a table containing the methods of the object and a pointer to the <strong>Class</strong> object that represents the type of the object, and the other to the memory allocated from the heap for the object data.</p>
</blockquote>
<h2 class="mume-header" id="28-floating-point-arithmetic">2.8 Floating-Point Arithmetic</h2>

<p>The Java Virtual Machine incorporates a subset of the floating-point arithmetic specified in IEEE Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std. 754-1985, New York).</p>
<h2 class="mume-header" id="29-special-methods">2.9 Special Methods</h2>

<p>At the level of the Java Virtual Machine, every constructor written in the Java programming language (JLS &#xA7;8.8) appears as an <em><strong>instance initialization method</strong></em> that has the special name <strong>&lt;init&gt;</strong>. This name is supplied by a compiler. Because that name <strong>&lt;init&gt;</strong> is not a valid identifier, it cannot be used directly in a program written in the Java programming language. Instance initialization methods may be invoked only within the Java Virtual Machine by the <strong>invokespecial</strong> instruction (&#xA7;invokespecial), and they may be invoked only on uninitialized class instances. An instance initialization method takes on the access permissions (JLS &#xA7;6.6) of the constructor from which it was derived.</p>
<p>A class or interface has at most one <em>class or interface initialization method</em> and is initialized (&#xA7;5.5) by invoking that method. The initialization method of a class or interface has the special name <strong>&lt;clinit&gt;</strong>, takes no arguments, and is void (&#xA7;4.3.3).</p>
<blockquote>
<p>Other methods named &lt;clinit&gt; in a <em>class</em> file are of no consequence. They are not class or interface initialization methods. They cannot be invoked by any Java Virtual Machine instruction and are never invoked by the Java Virtual Machine itself.</p>
</blockquote>
<p>In a <strong>class</strong> file whose version number is 51.0 or above, the method must additionally have its <strong>ACC_STATIC</strong> flag (&#xA7;4.6) set in order to be the class or interface initialization method.</p>
<blockquote>
<p>This requirement was introduced in Java SE 7. In a class file whose version number is 50.0 or below, a method named &lt;clinit&gt; that is void and takes no arguments is considered the class or interface initialization method regardless of the setting of its <strong>ACC_STATIC</strong> flag.</p>
</blockquote>
<p>The name <strong>&lt;clinit&gt;</strong> is supplied by a compiler. Because the name <strong>&lt;clinit&gt;</strong> is not a valid identifier, it cannot be used directly in a program written in the Java programming language. Class and interface initialization methods are invoked implicitly by the Java Virtual Machine; they are never invoked directly from any Java Virtual Machine instruction, but are invoked only indirectly as part of the class initialization process.</p>
<p>A method is <em>signature polymorphic</em> if all of the following are true:</p>
<ul>
<li>It is declared in the <em>java.lang.invoke.MethodHandle</em> class</li>
<li>It has a single formal parameter of type <em>Object[]</em>.</li>
<li>It has a return type of <em>Object</em>.</li>
<li>It has the ACC_VARARGS and ACC_NATIVE flags set.</li>
</ul>
<blockquote>
<p>In java SE 8, the only signature polymorphic methods are the <em>invoke</em> and <em>invokeExact</em> methods of the class <em>java.lang.invoke.MethodHandle</em>.</p>
</blockquote>
<p>The Java Virtual Machine gives special treatment to signature polymorphic methods in the <em><strong>invokevirtual</strong></em> instruction (&#xA7;invokevirtual), in order to effect invocation of a <em>method handle</em>. <strong>A method handle is a strongly typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation (&#xA7;5.4.3.5), with optional transformations of arguments or return values.</strong> These transformations are quite general, and include such patterns as conversion, insertion, deletion, and substitution. See the <em>java.lang.invoke</em> package in the Java SE platform API for more information.</p>
<h2 class="mume-header" id="210-exceptions">2.10 Exceptions</h2>

<p>An exception in the Java Virtual Machine is represented by an instance of the class <strong>Throwable</strong> or one of its subclasses. Throwing an exception results in an immediate non-local transfer of control from the point where the exception was thrown.</p>
<p>Most exceptions occur synchronously as a result of an action by the thread in which they occur. An asynchronous exception, by contrast, can potentially occur at any point in the execution of a program. The Java Virtual Machine throws an exception for one of three reasons:</p>
<ul>
<li>An <em><strong>athrow</strong></em> instruction (&#xA7;athrow) was executed.</li>
<li>An abnormal execution condition was synchronously detected by the Java Virtual Machine. These exceptions are not thrown at an arbitrary point in the program, but only synchronously after execution of an instruction that either:
<ul>
<li>Specifies the exception as a possible result, such as:
<ul>
<li>When the instruction embodies an operation that violates the semantics of the Java programming language, for example indexing outside the bounds of an array.</li>
<li>When an error occurs in loading or linking part of the program.</li>
</ul>
</li>
<li>Causes some limit on a resource to be exceeded, for example when too much memory is used.</li>
</ul>
</li>
<li>An asynchronous exception occurred because&#xFF1B;
<ul>
<li>The <em>stop</em> method of class <em>Thread</em> or <em>ThreadGroup</em> was invoked, or</li>
<li>An internal error occurred in the Java Virtual Machine implementation.<br>
The <em>stop</em> methods may be invoked by one thread to affect another thread or all the threads in a specified thread group. They are asynchronous because they may occur at any point in the execution of the other thread or threads. An internal error is considered asynchronous (&#xA7;6.3).</li>
</ul>
</li>
</ul>
<p>A Java virtual Machine may permit a small but bounded amount of execution to occur before an asynchronous exception is thrown. This delay is permitted to allow optimized code to detect and throw these exceptions at points where it is practical to handle them while obeying the semantics of the Java programming language.</p>
<p>Exceptions thrown by the Java Virtual Machine are precise: when the transfer of control takes place, all effects of the instructions executed before the point from which the exception is thrown must appear to have taken place. No instructions that occur after the point from which the exception is thrown may appear to have been evaluated. If optimized code has speculatively executed some of the instructions which follow the point at which the exception occurs, such code must be prepared to hide this speculative execution from the user-visible state of the program.</p>
<p>Each method in the Java Virtual Machine may be associated with zero or more <strong>exception handlers</strong>. An exception handler specifies the range of offsets into the Java Virtual Machine code implementing the method for which the exception handler is active, describes the type of exception that the exception handler is able to handle, and specifies the location of the code that is to handle that exception. An exception matches an exception handler if the offset of the instruction that caused the exception is in the range of offsets of the exception handler and the exception type is the same class as or a subclass of the class of exception that the exception handler handles. When an exception is thrown, the Java Virtual Machine searches for a matching exception handler in the current method. If a matching exception handler is found, the system branches to the exception handling code specified by the matched handler.</p>
<p>If no such exception handler is found in the current method, the current method invocation completes abruptly(&#xA7;2.6.5). On abrupt completion, the operand stack and local variables of the current method invocation are discarded, and its frame is popped, reinstating the frame of the invoking method. The exception is then rethrown in the context of the invoker&apos;s frame and so on, continuing up the method invocation chain. If no suitable exception handler is found before the top of the method invocation chain is reached, the execution of the thread in which the exception was thrown is terminated.</p>
<p>The order in which the exception handlers of a method are searched for a match is important. Within a <strong>class</strong> file, the exception handlers for each method are stored in a table (&#xA7;4.7.3). At run time, when an exception is thrown, the Java Virtual Machine searches the exception handlers of the current method in the order that they appear in the corresponding exception handler table in the <strong>class</strong> file, starting from the beginning of the table.</p>
<p>Note that the Java Virtual Machine does not enforce nesting of or any ordering of the exception table entries of a method. The exception handling semantics of the Java programming language are implemented only through cooperation with the compiler (&#xA7;3.12). When <strong>class</strong> files are generated by some other means, the defined search procedure ensures that all Java Virtual Machine implementations will behave consistently.</p>

      </div>
      
      
    
    
    
    
    
    
    
    
  
    </body></html>